%# -*-C-*- vi: set ft=c:
%# This file is processed in several stages.
%# Here are the stages, as best as I can describe:
%#
%#   1. flex.skl is processed through GNU m4 during the
%#      pre-compilation stage of flex. Only macros starting
%#      with `m4_' are processed, and quoting is normal.
%#
%#   2. The preprocessed skeleton is translated into a C array, saved
%#      as "skel.c" and compiled into the flex binary. The %# comment
%#      lines are removed.
%#
%#   3. At runtime, the skeleton is generated and filtered (again)
%#      through m4. Macros beginning with `m4_' will be processed.
%#      The quoting is "[[" and "]]" so we don't interfere with
%#      user code.
%#
%# All generated macros for the m4 stage contain the text "m4" or "M4"
%# in them. This is to distinguish them from CPP macros.
%# The exception to this rule is YY_G, which is an m4 macro,
%# but it needs to be remain short because it is used everywhere.
%#
/* A lexical scanner generated by flex */

%#  Macros for preproc stage.


%# Macros for runtime processing stage.
m4_changecom
m4_changequote
m4_changequote([[, ]])

%#
%# Lines in this skeleton starting with a "%" character are "control lines"
%# and affect the generation of the scanner. The possible control codes are
%# listed and processed in misc.c.
%#
%#   %#  -  A comment. The current line is omitted from the generated scanner.
%#   %if-c++-only  -  The following lines are printed for C++ scanners ONLY.
%#   %if-c-only    -  The following lines are NOT printed for C++ scanners.
%#   %if-c-or-c++  -  The following lines are printed in BOTH C and C++ scanners.
%#   %if-reentrant     - Print for reentrant scanners.(push)
%#   %if-not-reentrant - Print for non-reentrant scanners. (push)
%#   %if-bison-bridge  - Print for bison-bridge. (push)
%#   %if-not-bison-bridge  - Print for non-bison-bridge. (push)
%#   %endif        - pop from the previous if code.
%#   %%  -  A stop-point, where code is inserted by flex.
%#          Each stop-point is numbered here and also in the code generator.
%#          (See gen.c, etc. for details.)
%#   %not-for-header  -  Begin code that should NOT appear in a ".h" file.
%#   %ok-for-header   -  %c and %e are used for building a header file.
%#   %if-tables-serialization
%#
%#   All control-lines EXCEPT comment lines ("%#") will be inserted into
%#   the generated scanner as a C-style comment. This is to aid those who
%#   edit the skeleton.
%#

%not-for-header
%if-c-only
%if-not-reentrant
m4_ifelse(M4_YY_PREFIX,yy,,
#define yy_create_buffer M4_YY_PREFIX[[_create_buffer]]
#define yy_delete_buffer M4_YY_PREFIX[[_delete_buffer]]
#define yy_scan_buffer M4_YY_PREFIX[[_scan_buffer]]
#define yy_scan_string M4_YY_PREFIX[[_scan_string]]
#define yy_scan_bytes M4_YY_PREFIX[[_scan_bytes]]
#define yy_init_buffer M4_YY_PREFIX[[_init_buffer]]
#define yy_flush_buffer M4_YY_PREFIX[[_flush_buffer]]
#define yy_load_buffer_state M4_YY_PREFIX[[_load_buffer_state]]
#define yy_switch_to_buffer M4_YY_PREFIX[[_switch_to_buffer]]
#define yypush_buffer_state M4_YY_PREFIX[[push_buffer_state]]
#define yypop_buffer_state M4_YY_PREFIX[[pop_buffer_state]]
#define yyensure_buffer_stack M4_YY_PREFIX[[ensure_buffer_stack]]
#define yy_flex_debug M4_YY_PREFIX[[_flex_debug]]
#define yyin M4_YY_PREFIX[[in]]
#define yyleng M4_YY_PREFIX[[leng]]
#define yylex M4_YY_PREFIX[[lex]]
#define yylineno M4_YY_PREFIX[[lineno]]
#define yyout M4_YY_PREFIX[[out]]
#define yyrestart M4_YY_PREFIX[[restart]]
#define yytext M4_YY_PREFIX[[text]]
#define yywrap M4_YY_PREFIX[[wrap]]
#define yyalloc M4_YY_PREFIX[[alloc]]
#define yyrealloc M4_YY_PREFIX[[realloc]]
#define yyfree M4_YY_PREFIX[[free]]
)
%endif
%endif
%ok-for-header

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

%# Some negated symbols
m4_ifdef( [[M4_YY_IN_HEADER]], , [[m4_define([[M4_YY_NOT_IN_HEADER]], [[]])]])
m4_ifdef( [[M4_YY_REENTRANT]], , [[m4_define([[M4_YY_NOT_REENTRANT]], [[]])]])

%# This is the m4 way to say "(stack_used || is_reentrant)
m4_ifdef( [[M4_YY_STACK_USED]], [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])
m4_ifdef( [[M4_YY_REENTRANT]],  [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])

%# Prefixes.
%# The complexity here is necessary so that m4 preserves
%# the argument lists to each C function.


m4_ifdef( [[M4_YY_PREFIX]],, [[m4_define([[M4_YY_PREFIX]], [[yy]])]])



%if-c++-only
    /* The c++ scanner is a mess. The FlexLexer.h header file relies on the
     * following macro. This is required in order to pass the c++-multiple-scanners
     * test in the regression suite. We get reports that it breaks inheritance.
     * We will address this in a future release of flex, or omit the C++ scanner
     * altogether.
     */
    #define yyFlexLexer M4_YY_PREFIX[[FlexLexer]]
%endif

%if-c-only
m4_ifelse(M4_YY_PREFIX,yy,,
    
[[#ifdef yy_create_buffer
#define ]]M4_YY_PREFIX[[_create_buffer_ALREADY_DEFINED
#else
#define yy_create_buffer ]]M4_YY_PREFIX[[_create_buffer
#endif]]

    
[[#ifdef yy_delete_buffer
#define ]]M4_YY_PREFIX[[_delete_buffer_ALREADY_DEFINED
#else
#define yy_delete_buffer ]]M4_YY_PREFIX[[_delete_buffer
#endif]]

    
[[#ifdef yy_scan_buffer
#define ]]M4_YY_PREFIX[[_scan_buffer_ALREADY_DEFINED
#else
#define yy_scan_buffer ]]M4_YY_PREFIX[[_scan_buffer
#endif]]

    
[[#ifdef yy_scan_string
#define ]]M4_YY_PREFIX[[_scan_string_ALREADY_DEFINED
#else
#define yy_scan_string ]]M4_YY_PREFIX[[_scan_string
#endif]]

    
[[#ifdef yy_scan_bytes
#define ]]M4_YY_PREFIX[[_scan_bytes_ALREADY_DEFINED
#else
#define yy_scan_bytes ]]M4_YY_PREFIX[[_scan_bytes
#endif]]

    
[[#ifdef yy_init_buffer
#define ]]M4_YY_PREFIX[[_init_buffer_ALREADY_DEFINED
#else
#define yy_init_buffer ]]M4_YY_PREFIX[[_init_buffer
#endif]]

    
[[#ifdef yy_flush_buffer
#define ]]M4_YY_PREFIX[[_flush_buffer_ALREADY_DEFINED
#else
#define yy_flush_buffer ]]M4_YY_PREFIX[[_flush_buffer
#endif]]

    
[[#ifdef yy_load_buffer_state
#define ]]M4_YY_PREFIX[[_load_buffer_state_ALREADY_DEFINED
#else
#define yy_load_buffer_state ]]M4_YY_PREFIX[[_load_buffer_state
#endif]]

    
[[#ifdef yy_switch_to_buffer
#define ]]M4_YY_PREFIX[[_switch_to_buffer_ALREADY_DEFINED
#else
#define yy_switch_to_buffer ]]M4_YY_PREFIX[[_switch_to_buffer
#endif]]

    
[[#ifdef yypush_buffer_state
#define ]]M4_YY_PREFIX[[push_buffer_state_ALREADY_DEFINED
#else
#define yypush_buffer_state ]]M4_YY_PREFIX[[push_buffer_state
#endif]]

    
[[#ifdef yypop_buffer_state
#define ]]M4_YY_PREFIX[[pop_buffer_state_ALREADY_DEFINED
#else
#define yypop_buffer_state ]]M4_YY_PREFIX[[pop_buffer_state
#endif]]

    
[[#ifdef yyensure_buffer_stack
#define ]]M4_YY_PREFIX[[ensure_buffer_stack_ALREADY_DEFINED
#else
#define yyensure_buffer_stack ]]M4_YY_PREFIX[[ensure_buffer_stack
#endif]]

    
[[#ifdef yylex
#define ]]M4_YY_PREFIX[[lex_ALREADY_DEFINED
#else
#define yylex ]]M4_YY_PREFIX[[lex
#endif]]

    
[[#ifdef yyrestart
#define ]]M4_YY_PREFIX[[restart_ALREADY_DEFINED
#else
#define yyrestart ]]M4_YY_PREFIX[[restart
#endif]]

    
[[#ifdef yylex_init
#define ]]M4_YY_PREFIX[[lex_init_ALREADY_DEFINED
#else
#define yylex_init ]]M4_YY_PREFIX[[lex_init
#endif]]

    
[[#ifdef yylex_init_extra
#define ]]M4_YY_PREFIX[[lex_init_extra_ALREADY_DEFINED
#else
#define yylex_init_extra ]]M4_YY_PREFIX[[lex_init_extra
#endif]]

    
[[#ifdef yylex_destroy
#define ]]M4_YY_PREFIX[[lex_destroy_ALREADY_DEFINED
#else
#define yylex_destroy ]]M4_YY_PREFIX[[lex_destroy
#endif]]

    
[[#ifdef yyget_debug
#define ]]M4_YY_PREFIX[[get_debug_ALREADY_DEFINED
#else
#define yyget_debug ]]M4_YY_PREFIX[[get_debug
#endif]]

    
[[#ifdef yyset_debug
#define ]]M4_YY_PREFIX[[set_debug_ALREADY_DEFINED
#else
#define yyset_debug ]]M4_YY_PREFIX[[set_debug
#endif]]

    
[[#ifdef yyget_extra
#define ]]M4_YY_PREFIX[[get_extra_ALREADY_DEFINED
#else
#define yyget_extra ]]M4_YY_PREFIX[[get_extra
#endif]]

    
[[#ifdef yyset_extra
#define ]]M4_YY_PREFIX[[set_extra_ALREADY_DEFINED
#else
#define yyset_extra ]]M4_YY_PREFIX[[set_extra
#endif]]

    
[[#ifdef yyget_in
#define ]]M4_YY_PREFIX[[get_in_ALREADY_DEFINED
#else
#define yyget_in ]]M4_YY_PREFIX[[get_in
#endif]]

    
[[#ifdef yyset_in
#define ]]M4_YY_PREFIX[[set_in_ALREADY_DEFINED
#else
#define yyset_in ]]M4_YY_PREFIX[[set_in
#endif]]

    
[[#ifdef yyget_out
#define ]]M4_YY_PREFIX[[get_out_ALREADY_DEFINED
#else
#define yyget_out ]]M4_YY_PREFIX[[get_out
#endif]]

    
[[#ifdef yyset_out
#define ]]M4_YY_PREFIX[[set_out_ALREADY_DEFINED
#else
#define yyset_out ]]M4_YY_PREFIX[[set_out
#endif]]

    
[[#ifdef yyget_leng
#define ]]M4_YY_PREFIX[[get_leng_ALREADY_DEFINED
#else
#define yyget_leng ]]M4_YY_PREFIX[[get_leng
#endif]]

    
[[#ifdef yyget_text
#define ]]M4_YY_PREFIX[[get_text_ALREADY_DEFINED
#else
#define yyget_text ]]M4_YY_PREFIX[[get_text
#endif]]

    
[[#ifdef yyget_lineno
#define ]]M4_YY_PREFIX[[get_lineno_ALREADY_DEFINED
#else
#define yyget_lineno ]]M4_YY_PREFIX[[get_lineno
#endif]]

    
[[#ifdef yyset_lineno
#define ]]M4_YY_PREFIX[[set_lineno_ALREADY_DEFINED
#else
#define yyset_lineno ]]M4_YY_PREFIX[[set_lineno
#endif]]

    m4_ifdef( [[M4_YY_REENTRANT]],
    [[
        
[[#ifdef yyget_column
#define ]]M4_YY_PREFIX[[get_column_ALREADY_DEFINED
#else
#define yyget_column ]]M4_YY_PREFIX[[get_column
#endif]]

        
[[#ifdef yyset_column
#define ]]M4_YY_PREFIX[[set_column_ALREADY_DEFINED
#else
#define yyset_column ]]M4_YY_PREFIX[[set_column
#endif]]

    ]])
    
[[#ifdef yywrap
#define ]]M4_YY_PREFIX[[wrap_ALREADY_DEFINED
#else
#define yywrap ]]M4_YY_PREFIX[[wrap
#endif]]

)
%endif

m4_ifdef( [[M4_YY_BISON_LVAL]],
[[
    
[[#ifdef yyget_lval
#define ]]M4_YY_PREFIX[[get_lval_ALREADY_DEFINED
#else
#define yyget_lval ]]M4_YY_PREFIX[[get_lval
#endif]]

    
[[#ifdef yyset_lval
#define ]]M4_YY_PREFIX[[set_lval_ALREADY_DEFINED
#else
#define yyset_lval ]]M4_YY_PREFIX[[set_lval
#endif]]

]])

m4_ifdef( [[<M4_YY_BISON_LLOC>]],
[[
    
[[#ifdef yyget_lloc
#define ]]M4_YY_PREFIX[[get_lloc_ALREADY_DEFINED
#else
#define yyget_lloc ]]M4_YY_PREFIX[[get_lloc
#endif]]

    
[[#ifdef yyset_lloc
#define ]]M4_YY_PREFIX[[set_lloc_ALREADY_DEFINED
#else
#define yyset_lloc ]]M4_YY_PREFIX[[set_lloc
#endif]]

]])


m4_ifelse(M4_YY_PREFIX,yy,,
    
[[#ifdef yyalloc
#define ]]M4_YY_PREFIX[[alloc_ALREADY_DEFINED
#else
#define yyalloc ]]M4_YY_PREFIX[[alloc
#endif]]

    
[[#ifdef yyrealloc
#define ]]M4_YY_PREFIX[[realloc_ALREADY_DEFINED
#else
#define yyrealloc ]]M4_YY_PREFIX[[realloc
#endif]]

    
[[#ifdef yyfree
#define ]]M4_YY_PREFIX[[free_ALREADY_DEFINED
#else
#define yyfree ]]M4_YY_PREFIX[[free
#endif]]

)

%if-c-only
m4_ifelse(M4_YY_PREFIX,yy,,
m4_ifdef( [[M4_YY_NOT_REENTRANT]],
[[
    
[[#ifdef yytext
#define ]]M4_YY_PREFIX[[text_ALREADY_DEFINED
#else
#define yytext ]]M4_YY_PREFIX[[text
#endif]]

    
[[#ifdef yyleng
#define ]]M4_YY_PREFIX[[leng_ALREADY_DEFINED
#else
#define yyleng ]]M4_YY_PREFIX[[leng
#endif]]

    
[[#ifdef yyin
#define ]]M4_YY_PREFIX[[in_ALREADY_DEFINED
#else
#define yyin ]]M4_YY_PREFIX[[in
#endif]]

    
[[#ifdef yyout
#define ]]M4_YY_PREFIX[[out_ALREADY_DEFINED
#else
#define yyout ]]M4_YY_PREFIX[[out
#endif]]

    
[[#ifdef yy_flex_debug
#define ]]M4_YY_PREFIX[[_flex_debug_ALREADY_DEFINED
#else
#define yy_flex_debug ]]M4_YY_PREFIX[[_flex_debug
#endif]]

    
[[#ifdef yylineno
#define ]]M4_YY_PREFIX[[lineno_ALREADY_DEFINED
#else
#define yylineno ]]M4_YY_PREFIX[[lineno
#endif]]

]])
)
%endif


m4_ifdef( [[M4_YY_TABLES_EXTERNAL]],
[[
    
[[#ifdef yytables_fload
#define ]]M4_YY_PREFIX[[tables_fload_ALREADY_DEFINED
#else
#define yytables_fload ]]M4_YY_PREFIX[[tables_fload
#endif]]

    
[[#ifdef yytables_destroy
#define ]]M4_YY_PREFIX[[tables_destroy_ALREADY_DEFINED
#else
#define yytables_destroy ]]M4_YY_PREFIX[[tables_destroy
#endif]]

    
[[#ifdef yyTABLES_NAME
#define ]]M4_YY_PREFIX[[TABLES_NAME_ALREADY_DEFINED
#else
#define yyTABLES_NAME ]]M4_YY_PREFIX[[TABLES_NAME
#endif]]

]])

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
%if-c-only
m4_ifdef( [[M4_YY_ALWAYS_INTERACTIVE]], ,
[[m4_ifdef( [[M4_YY_NEVER_INTERACTIVE]], ,
[[/* Feature test macros. Flex uses functions that require a minimum set of
 * macros defined. As defining some macros may hide function declarations that
 * user code might use, be conservative and respect user's definitions as much
 * as possible. In glibc, feature test macros may not be all set up until one
 * of the libc header (that includes <features.h>) is included. This creates
 * a circular dependency when we check the macros. <assert.h> is the safest
 * header we can include and does not declare too many functions we don't need.
 */
#if !defined(__GNU_LIBRARY__) && defined(__STDC__)
#include <assert.h>
#endif
#if !(defined(_POSIX_C_SOURCE) || defined(_XOPEN_SOURCE) || \
    defined(_POSIX_SOURCE))
# define _POSIX_C_SOURCE 1 /* Required for fileno() */
# define _POSIX_SOURCE 1
#endif]])]])
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
%endif

%if-tables-serialization
#include <sys/types.h>
#include <netinet/in.h>
%endif
/* end standard C headers. */

/* begin standard C++ headers. */
%if-c++-only
#include <iostream>
#include <errno.h>
#include <cstdlib>
#include <cstdio>
#include <cstring>
/* end standard C++ headers. */
%endif

%if-c-or-c++
/* flex integer type definitions */

#ifndef YYFLEX_INTTYPES_DEFINED
#define YYFLEX_INTTYPES_DEFINED

/* Prefer C99 integer types if available. */
# if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
/* Include <inttypes.h> and not <stdint.h> because Solaris 2.6 has the former
 * and not the latter.
 */
#include <inttypes.h>
#  define YYFLEX_USE_STDINT
# else
#  if defined(_MSC_VER) && _MSC_VER >= 1600
/* Visual C++ 2010 does not define __STDC_VERSION__ and has <stdint.h> but not
 * <inttypes.h>.
 */
#include <stdint.h>
#   define YYFLEX_USE_STDINT
#  endif
# endif
# ifdef YYFLEX_USE_STDINT
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
# else
typedef unsigned char flex_uint8_t;
typedef short int flex_int16_t;
typedef unsigned short int flex_uint16_t;
#  ifdef __STDC__
typedef signed char flex_int8_t;
/* ISO C only requires at least 16 bits for int. */
#include <limits.h>
#   if UINT_MAX >= 4294967295
#    define YYFLEX_INT32_DEFINED
typedef int flex_int32_t;
typedef unsigned int flex_uint32_t;
#   endif
#  else
typedef char flex_int8_t;
#  endif
#  ifndef YYFLEX_INT32_DEFINED
typedef long int flex_int32_t;
typedef unsigned long int flex_uint32_t;
#  endif
# endif
#endif /* YYFLEX_INTTYPES_DEFINED */

%endif

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

%not-for-header
/* Returned upon end-of-file. */
#define YY_NULL 0
%ok-for-header

%not-for-header
/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
%ok-for-header



%if-reentrant

/* An opaque pointer. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

%# Declare yyguts variable
m4_define( [[M4_YY_DECL_GUTS_VAR]], [[struct yyguts_t * yyg = (struct yyguts_t*)yyscanner]])
%# Perform a noop access on yyguts to prevent unused variable complains
m4_define( [[M4_YY_NOOP_GUTS_VAR]], [[(void)yyg]])
%# For use wherever a Global is accessed or assigned.
m4_define( [[YY_G]], [[yyg->$1]])

%# For use in function prototypes to append the additional argument.
m4_define( [[M4_YY_PROTO_LAST_ARG]],  [[, yyscan_t yyscanner]])
m4_define( [[M4_YY_PROTO_ONLY_ARG]],  [[yyscan_t yyscanner]])

m4_define( [[M4_YY_DEF_LAST_ARG]],  [[, yyscan_t yyscanner]])
m4_define( [[M4_YY_DEF_ONLY_ARG]],  [[yyscan_t yyscanner]])
m4_define( [[M4_YY_DECL_LAST_ARG]],  [[yyscan_t yyscanner;]])

%# For use in function calls to pass the additional argument.
m4_define( [[M4_YY_CALL_LAST_ARG]], [[, yyscanner]])
m4_define( [[M4_YY_CALL_ONLY_ARG]], [[yyscanner]])

%# For use in function documentation to adjust for additional argument.
m4_define( [[M4_YY_DOC_PARAM]], [[@param yyscanner The scanner object.]])

/* For convenience, these vars (plus the bison vars far below)
   are macros in the reentrant scanner. */
#define yyin YY_G(yyin_r)
#define yyout YY_G(yyout_r)
#define yyextra YY_G(yyextra_r)
#define yyleng YY_G(yyleng_r)
#define yytext YY_G(yytext_r)
#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
#define yy_flex_debug YY_G(yy_flex_debug_r)

m4_define( [[M4_YY_INCR_LINENO]],
[[
    do{ yylineno++;
        yycolumn=0;
    }while(0)
]])

%endif



%if-not-reentrant

m4_define( [[M4_YY_INCR_LINENO]],
[[
    yylineno++;
]])

%# Define these macros to be no-ops.
m4_define( [[M4_YY_DECL_GUTS_VAR]], [[m4_dnl]])
m4_define( [[M4_YY_NOOP_GUTS_VAR]], [[m4_dnl]])
m4_define( [[YY_G]], [[($1)]])
m4_define( [[M4_YY_PROTO_LAST_ARG]])
m4_define( [[M4_YY_PROTO_ONLY_ARG]],  [[void]])
m4_define( [[M4_YY_DEF_LAST_ARG]])

m4_define( [[M4_YY_DEF_ONLY_ARG]],  [[void]])
m4_define([[M4_YY_DECL_LAST_ARG]])
m4_define([[M4_YY_CALL_LAST_ARG]])
m4_define([[M4_YY_CALL_ONLY_ARG]])
m4_define( [[M4_YY_DOC_PARAM]], )

%endif


%# Generate C99 function defs.
m4_define( [[YYFARGS1]], [[($1 $2 M4_YY_DEF_LAST_ARG)]])
m4_define( [[YYFARGS2]], [[($1 $2, $3 $4 M4_YY_DEF_LAST_ARG)]])
m4_define( [[YYFARGS3]], [[($1 $2, $3 $4, $5 $6 M4_YY_DEF_LAST_ARG)]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN YY_G(yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((YY_G(yy_start) - 1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin M4_YY_CALL_LAST_ARG )
#define YY_END_OF_BUFFER_CHAR 0
]])

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
]])


#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

%if-not-reentrant
extern int yyleng;
%endif

%if-c-only
%if-not-reentrant
extern FILE *yyin, *yyout;
%endif
%endif

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2
    m4_ifdef( [[M4_YY_USE_LINENO]],
    [[
    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
     *       access to the local variable yy_act. Since yyless() is a macro, it would break
     *       existing scanners that call yyless() from OUTSIDE yylex.
     *       One obvious solution it to make yy_act a global. I tried that, and saw
     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
     *       normally declared as a register variable-- so it is not worth it.
     */
    #define  YY_LESS_LINENO(n) \
            do { \
                int yyl;\
                for ( yyl = n; yyl < yyleng; ++yyl )\
                    if ( yytext[yyl] == '\n' )\
                        --yylineno;\
            }while(0)
    #define YY_LINENO_REWIND_TO(dst) \
            do {\
                const char *p;\
                for ( p = yy_cp-1; p >= (dst); --p)\
                    if ( *p == '\n' )\
                        --yylineno;\
            }while(0)
    ]],
    [[
    #define YY_LESS_LINENO(n)
    #define YY_LINENO_REWIND_TO(ptr)
    ]])
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = YY_G(yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		YY_G(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )
#define unput(c) yyunput( c, YY_G(yytext_ptr) M4_YY_CALL_LAST_ARG )
]])

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
%if-c-only
	FILE *yy_input_file;
%endif

%if-c++-only
	std::streambuf* yy_input_file;
%endif


	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	int yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */


	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;
m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2
]])
	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

%if-c-only Standard (non-C++) definition
%not-for-header
%if-not-reentrant

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
%endif
%ok-for-header
%endif

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( YY_G(yy_buffer_stack) \
                          ? YY_G(yy_buffer_stack)[YY_G(yy_buffer_stack_top)] \
                          : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE YY_G(yy_buffer_stack)[YY_G(yy_buffer_stack_top)]
]])

%if-c-only Standard (non-C++) definition

%if-not-reentrant
%not-for-header
/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars;		/* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = NULL;
static int yy_init = 0;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;
%ok-for-header
%endif

void yyrestart ( FILE *input_file M4_YY_PROTO_LAST_ARG );
void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer M4_YY_PROTO_LAST_ARG );
YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size M4_YY_PROTO_LAST_ARG );
void yy_delete_buffer ( YY_BUFFER_STATE b M4_YY_PROTO_LAST_ARG );
void yy_flush_buffer ( YY_BUFFER_STATE b M4_YY_PROTO_LAST_ARG );
void yypush_buffer_state ( YY_BUFFER_STATE new_buffer M4_YY_PROTO_LAST_ARG );
void yypop_buffer_state ( M4_YY_PROTO_ONLY_ARG );

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
static void yyensure_buffer_stack ( M4_YY_PROTO_ONLY_ARG );
static void yy_load_buffer_state ( M4_YY_PROTO_ONLY_ARG );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file M4_YY_PROTO_LAST_ARG );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG)
]])

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size M4_YY_PROTO_LAST_ARG );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str M4_YY_PROTO_LAST_ARG );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len M4_YY_PROTO_LAST_ARG );

%endif

void *yyalloc ( yy_size_t M4_YY_PROTO_LAST_ARG );
void *yyrealloc ( void *, yy_size_t M4_YY_PROTO_LAST_ARG );
void yyfree ( void * M4_YY_PROTO_LAST_ARG );

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}
#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
]])

%% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
%% [1.5] DFA
]])

%if-c-only Standard (non-C++) definition

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
static yy_state_type yy_get_previous_state ( M4_YY_PROTO_ONLY_ARG );
static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  M4_YY_PROTO_LAST_ARG);
static int yy_get_next_buffer ( M4_YY_PROTO_ONLY_ARG );
static void yynoreturn yy_fatal_error ( const char* msg M4_YY_PROTO_LAST_ARG );
]])

%endif

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	YY_G(yytext_ptr) = yy_bp; \
%% [2.0] code to fiddle yytext and yyleng for yymore() goes here \
	YY_G(yy_hold_char) = *yy_cp; \
	*yy_cp = '\0'; \
%% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array \
	YY_G(yy_c_buf_p) = yy_cp;
%% [4.0] data tables for the DFA and the user's section 1 definitions go here
]])

m4_ifdef( [[M4_YY_IN_HEADER]], [[#ifdef YY_HEADER_EXPORT_START_CONDITIONS]])
M4_YY_SC_DEFS
m4_ifdef( [[M4_YY_IN_HEADER]], [[#endif]])

m4_ifdef( [[M4_YY_NO_UNISTD_H]],,
[[
#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
%if-c-only
#include <unistd.h>
%endif
%if-c++-only
#include <unistd.h>
%endif
#endif
]])

m4_ifdef( [[M4_EXTRA_TYPE_DEFS]],
[[
#define YY_EXTRA_TYPE M4_EXTRA_TYPE_DEFS
]],
[[
#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif
]]
)

%if-c-only Reentrant structure and macros (non-C++).
%if-reentrant

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* Holds the entire state of the reentrant scanner. */
struct yyguts_t
    {

    /* User-defined. Not touched by flex. */
    YY_EXTRA_TYPE yyextra_r;

    /* The rest are the same as the globals declared in the non-reentrant scanner. */
    FILE *yyin_r, *yyout_r;
    size_t yy_buffer_stack_top; /**< index of top of stack. */
    size_t yy_buffer_stack_max; /**< capacity of stack. */
    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
    char yy_hold_char;
    int yy_n_chars;
    int yyleng_r;
    char *yy_c_buf_p;
    int yy_init;
    int yy_start;
    int yy_did_buffer_switch_on_eof;
    int yy_start_stack_ptr;
    int yy_start_stack_depth;
    int *yy_start_stack;
    yy_state_type yy_last_accepting_state;
    char* yy_last_accepting_cpos;

    int yylineno_r;
    int yy_flex_debug_r;

m4_ifdef( [[M4_YY_USES_REJECT]],
[[
    yy_state_type *yy_state_buf;
    yy_state_type *yy_state_ptr;
    char *yy_full_match;
    int yy_lp;

    /* These are only needed for trailing context rules,
     * but there's no conditional variable for that yet. */
    int yy_looking_for_trail_begin;
    int yy_full_lp;
    int *yy_full_state;
]])

m4_ifdef( [[M4_YY_TEXT_IS_ARRAY]],
[[
    char yytext_r[YYLMAX];
    char *yytext_ptr;
    int yy_more_offset;
    int yy_prev_more_offset;
]],
[[
    char *yytext_r;
    int yy_more_flag;
    int yy_more_len;
]])

m4_ifdef( [[M4_YY_BISON_LVAL]],
[[
    YYSTYPE * yylval_r;
]])

m4_ifdef( [[<M4_YY_BISON_LLOC>]],
[[
    YYLTYPE * yylloc_r;
]])

    }; /* end struct yyguts_t */
]])


%if-c-only
m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
static int yy_init_globals ( M4_YY_PROTO_ONLY_ARG );
]])
%endif

%if-reentrant

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
    m4_ifdef( [[M4_YY_BISON_LVAL]],
    [[
    /* This must go here because YYSTYPE and YYLTYPE are included
     * from bison output in section 1.*/
    #    define yylval YY_G(yylval_r)
    ]])

    m4_ifdef( [[<M4_YY_BISON_LLOC>]],
    [[
    #    define yylloc YY_G(yylloc_r)
    ]])
]])

int yylex_init (yyscan_t* scanner);

int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);

%endif

%endif End reentrant structures and macros.
